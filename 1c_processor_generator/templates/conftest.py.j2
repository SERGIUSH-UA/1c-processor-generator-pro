"""
Pytest fixtures для тестування EPF файлів через COM (auto-generated)
"""

import pytest
import logging
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Import EPFTester (handling module name starting with digit)
import sys
from pathlib import Path

# Add project root to path
# Path: .../tmp/ProcessorName/tests/conftest.py
# Need: .../1c-processor-generator/
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))

# Import 1c_processor_generator package using importlib
# This handles the package name starting with a digit
import importlib
epf_tester_pkg = importlib.import_module("1c_processor_generator.epf_tester")
external_conn_pkg = importlib.import_module("1c_processor_generator.external_connection")

EPFTester = epf_tester_pkg.EPFTester
HAS_COM_SUPPORT = epf_tester_pkg.HAS_COM_SUPPORT
ExternalConnection = external_conn_pkg.ExternalConnection

# EPF and IB paths
EPF_PATH = r"{{ epf_path }}"
{% if persistent_ib_path %}
IB_PATH = r"{{ persistent_ib_path }}"
{% else %}
# Default: use persistent_ib from cache
import os
IB_PATH = os.path.join(os.getenv("APPDATA"), "1C", "epf_compiler_cache", "persistent_ib")
{% endif %}

@pytest.fixture(scope="session")
def check_com_support():
    """Перевірка наявності COM підтримки"""
    if not HAS_COM_SUPPORT:
        pytest.skip("pywin32 не встановлено. COM тести пропущено.")

    logger.info("✅ COM підтримка доступна")

@pytest.fixture(scope="session")
def epf_tester(check_com_support):
    """
    Створює EPFTester з підключенням до тестової бази.

    Використовується на рівні сесії - одне підключення для всіх тестів.

    Architecture (v2.17.0+): Dependency Injection
    - Creates connection object (ExternalConnection or AutomationServerConnection)
    - Passes connection to EPFTester
    """
    logger.info(f"Створення EPFTester для {EPF_PATH}")

    {% if use_external_connection %}
    # Create External Connection (fast, no UI)
    connection = ExternalConnection(
        epf_path=Path(EPF_PATH),
        ib_path=Path(IB_PATH),
        {% if load_from_configuration %}
        load_from_configuration=True,  # v2.16.0+: обробка в конфігурації (без security warning)
        processor_name="{{ processor_name }}",
        {% endif %}
    )
    {% elif use_automation_server %}
    # Create Automation Server Connection (with UI)
    automation_conn_pkg = importlib.import_module("1c_processor_generator.automation_connection")
    AutomationServerConnection = automation_conn_pkg.AutomationServerConnection
    connection = AutomationServerConnection(
        epf_path=Path(EPF_PATH),
        ib_path=Path(IB_PATH),
        {% if load_from_configuration %}
        load_from_configuration=True,
        processor_name="{{ processor_name }}",
        {% endif %}
    )
    {% endif %}

    # Create EPFTester with dependency injection
    tester = EPFTester(connection=connection)

    # Connect to 1C infobase
    connected = tester.connect()

    if not connected:
        pytest.fail(f"Не вдалося підключитися до {IB_PATH}")

    yield tester

    # Cleanup
    tester.disconnect()
    logger.info("Тестування завершено")

@pytest.fixture(scope="function")
def processor(epf_tester):
    """
    Надає доступ до processor об'єкту для кожного тесту.

    Function-scope - кожен тест отримує "чистий" стан.
    """
    # Тут можна додати логіку очищення стану між тестами
    # Наприклад, скидання атрибутів або очищення таблиць

    yield epf_tester

# Додаткові корисні fixtures

@pytest.fixture
def clear_processor_state(processor):
    """Очищає стан обробки перед тестом"""
    # TODO: Додати логіку очищення атрибутів/таблиць якщо потрібно
    pass
